import { useEffect, useState, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Settings, ChevronLeft, ChevronRight, Image, Type } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { toast } from "sonner";
import { WordInput } from "@/components/learning/WordInput";
import { VirtualKeyboard } from "@/components/learning/VirtualKeyboard";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

import { getWords } from "@/storage/words";
import { getCategories } from "@/storage/categories";
import { loadImageFile } from "@/storage/files";
import { getImageDisplayMode, getCelebrationEnabled } from "@/storage/settings";
import { playAudio, playPhonics, getLastPlayedAudio, stopAudio, speakWord } from "@/lib/audio";
import { hapticTap } from "@/lib/haptics";

/* =========================
   DEVICE & ORIENTATION DETECTION
========================= */
const useDeviceLayout = () => {
  const [layout, setLayout] = useState<'mobile-portrait' | 'mobile-landscape' | 'ipad-portrait' | 'ipad-landscape'>('mobile-portrait');

  useEffect(() => {
    const updateLayout = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      const isPortrait = height > width;
      // Mobile: up to 6.5 inch screen (930px in landscape mode, 430px in portrait)
      const isMobile = (isPortrait && width <= 430) || (!isPortrait && width <= 930);

      if (isMobile && isPortrait) {
        setLayout('mobile-portrait');
      } else if (isMobile && !isPortrait) {
        setLayout('mobile-landscape');
      } else if (!isMobile && isPortrait) {
        setLayout('ipad-portrait');
      } else {
        setLayout('ipad-landscape');
      }
    };

    updateLayout();
    window.addEventListener('resize', updateLayout);
    window.addEventListener('orientationchange', updateLayout);

    return () => {
      window.removeEventListener('resize', updateLayout);
      window.removeEventListener('orientationchange', updateLayout);
    };
  }, []);

  return layout;
};

/* =========================
   TYPES
========================= */
interface Word {
  id: string;
  word: string;
  image: string;
  category_id: string | null;
}

interface Category {
  id: string;
  name: string;
}

type LearningMode = "image-first" | "word-first";

/* =========================
   AUDIO MANAGEMENT
========================= */
let lastPlayedAudio = "";
let idleTimer: number | null = null;
let audioContext: AudioContext | null = null;

/* =========================
   COMPONENT
========================= */
const Learning = () => {
  const navigate = useNavigate();
  const layout = useDeviceLayout();

  // Resume audio context on first user interaction
  useEffect(() => {
    const resumeAudio = async () => {
      if (!audioContext) {
        audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      }
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
    };

    const handleInteraction = () => {
      resumeAudio();
      window.removeEventListener('click', handleInteraction);
      window.removeEventListener('keydown', handleInteraction);
      window.removeEventListener('touchstart', handleInteraction);
    };

    window.addEventListener('click', handleInteraction);
    window.addEventListener('keydown', handleInteraction);
    window.addEventListener('touchstart', handleInteraction);

    return () => {
      window.removeEventListener('click', handleInteraction);
      window.removeEventListener('keydown', handleInteraction);
      window.removeEventListener('touchstart', handleInteraction);
    };
  }, []);

  // Warm up TTS ONCE on mount (prevents first-time freeze)
  useEffect(() => {
    if ("speechSynthesis" in window) {
      try {
        window.speechSynthesis.getVoices();
      } catch (error) {
        console.error('TTS warmup error:', error);
      }
    }
  }, []);

  const [allWords, setAllWords] = useState<Word[]>([]);
  const [words, setWords] = useState<Word[]>([]);
  const [categories, setCategories] = useState<Category[]>([]);
  const [selectedCategory, setSelectedCategory] = useState("all");
  const [pendingCategory, setPendingCategory] = useState("all");

  const [currentIndex, setCurrentIndex] = useState(0);
  const [currentWord, setCurrentWord] = useState<Word | null>(null);
  const [currentInput, setCurrentInput] = useState("");
  const [suggestion, setSuggestion] = useState("");
  const [highlightedKey, setHighlightedKey] = useState("");
  const [mode, setMode] = useState<LearningMode>("image-first");
  const [wordCompleted, setWordCompleted] = useState(false);
  const [imageSrc, setImageSrc] = useState("");
  const [imageKey, setImageKey] = useState(0);
  const [showBalloons, setShowBalloons] = useState(false);
  const [balloons, setBalloons] = useState<Array<{id: number, x: number, popped: boolean}>>([]);
  const [stars, setStars] = useState<Array<{id: number, x: number, y: number}>>([]);
  const [confetti, setConfetti] = useState<Array<{id: number, x: number, y: number, vx: number, vy: number}>>([]);
  const [categoryChanging, setCategoryChanging] = useState(false);
  
  // For random mode: shuffled indices to avoid repeats
  const [shuffledIndices, setShuffledIndices] = useState<number[]>([]);
  const [shufflePosition, setShufflePosition] = useState(0);

  // For repetitive speech - use ref to avoid stale closure issues
  const repeatIntervalRef = useRef<number | null>(null);
  const celebrationTimerRef = useRef<number | null>(null);
  const categoryDebounceRef = useRef<number | null>(null);
  const categoryChangeTimerRef = useRef<number | null>(null);
  const ttsSpokenRef = useRef(false);

  const hardStopAudio = () => {
    // Stop any playing audio
    stopAudio();
    
    // Clear idle timer
    if (idleTimer) {
      clearTimeout(idleTimer);
      idleTimer = null;
    }
  };

  // Sync currentWord with words array
  useEffect(() => {
    if (words.length === 0) {
      setCurrentWord(null);
      return;
    }

    setCurrentWord(words[currentIndex]);
  }, [words, currentIndex]);

  // Debug log to verify currentWord updates correctly
  useEffect(() => {
    console.log("CURRENT WORD:", currentWord?.word);
  }, [currentWord]);

  useEffect(() => {
    ttsSpokenRef.current = false;
  }, [currentWord?.id]);

  const speakWordTTS = (word: string) => {
    if (!word) return;
    if (ttsSpokenRef.current) return;
    ttsSpokenRef.current = true;
    console.log("TTS SPEAK", word);
    try {
      const firstLetter = word[0]?.toLowerCase() ?? "";
      speakWord(firstLetter, word);
    } catch (error) {
      console.error('TTS error:', error);
      playPhonics(word).catch(err => console.error('Phonics fallback error:', err));
    }
  };

  const changeImage = () => {
    if (!words.length) return;

    console.log("CHANGE IMAGE called - current index:", currentIndex, "total words:", words.length);
    
    setWordCompleted(false);
    setCurrentInput("");

    setCurrentIndex(i => {
      const next = (i + 1) % words.length;
      console.log("New index will be:", next);
      return next;
    });
  };

  const runCelebrationThenChangeImage = () => {
    console.log("CELEBRATION START", currentWord?.word);
    if (celebrationTimerRef.current) {
      clearTimeout(celebrationTimerRef.current);
      celebrationTimerRef.current = null;
    }

    // Play celebratory claps
    playClap();
    setTimeout(() => playClap(), 200);
    setTimeout(() => playClap(), 400);

    // Show balloons celebration with 4 balloons
    setShowBalloons(true);
    setBalloons([
      { id: 1, x: 15 + Math.random() * 15, popped: false },
      { id: 2, x: 35 + Math.random() * 15, popped: false },
      { id: 3, x: 55 + Math.random() * 15, popped: false },
      { id: 4, x: 75 + Math.random() * 15, popped: false }
    ]);

    // Create confetti burst
    const confettiPieces = Array.from({ length: 30 }, (_, i) => ({
      id: Date.now() + i,
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      vx: (Math.random() - 0.5) * 8,
      vy: (Math.random() - 0.5) * 8 - 3
    }));
    setConfetti(confettiPieces);

    // Remove confetti after animation
    setTimeout(() => {
      setConfetti([]);
    }, 4000);

    celebrationTimerRef.current = window.setTimeout(() => {
      console.log("CELEBRATION TIMER END - Clearing UI");
      
      // First, clear the celebration UI
      setShowBalloons(false);
      setBalloons([]);
      setStars([]);
      
      // Then, wait for next frame before changing image to ensure UI cleared
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          console.log("Now changing image after celebration cleared");
          changeImage();
        });
      });
    }, 4000);
  };

  /* SHUFFLE HELPER */
  const createShuffledIndices = (length: number): number[] => {
    const indices = Array.from({ length }, (_, i) => i);
    // Fisher-Yates shuffle
    for (let i = indices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    return indices;
  };

  /* LOAD DATA */
  useEffect(() => {
    Promise.all([getWords(), getCategories()]).then(
      ([loadedWords, loadedCategories]) => {
        if (!loadedWords.length) {
          toast.error("No words found. Add words in Settings.");
        }
        
        const normalized = loadedWords.map(w => ({
          ...w,
          category_id: w.category_id === "none" ? null : w.category_id
        }));
        
        setAllWords(normalized);
        // Don't set words here, let category filter handle the ordering
        setCategories(loadedCategories);
      }
    );
  }, []);



  useEffect(() => {
    setPendingCategory(selectedCategory);
  }, [selectedCategory]);

  useEffect(() => {
    return () => {
      if (categoryDebounceRef.current) {
        clearTimeout(categoryDebounceRef.current);
        categoryDebounceRef.current = null;
      }
    };
  }, []);

  useEffect(() => {
    setImageKey(k => k + 1);
  }, [currentWord?.id]);

  /* LOAD IMAGE */
  useEffect(() => {
    if (!currentWord?.image) {
      setImageSrc("");
      return;
    }
    loadImageFile(currentWord.image)
      .then(setImageSrc)
      .catch(() => setImageSrc(""));
  }, [currentWord]);

  /* RESET WORD */
  useEffect(() => {
    if (!currentWord) return;
    
    // Skip reset during celebration to prevent premature image/word changes
    if (showBalloons) {
      console.log("SKIPPING RESET - celebration active for:", currentWord.word);
      return;
    }
    
    console.log("RESET WORD effect for:", currentWord.word, "showBalloons:", showBalloons);
    setCurrentInput("");
    setWordCompleted(false);
    
    const first = currentWord.word[0];
    setSuggestion(first.toUpperCase());
    setHighlightedKey(first.toLowerCase());

    // Clear any existing idle timer
    if (idleTimer) {
      clearTimeout(idleTimer);
      idleTimer = null;
    }

    // Speak first letter using phonics (no TTS prompt)
    const playFirstLetterPhonics = async () => {
      try {
        // Play first letter using phonics only
        await playPhonics(first);
      } catch (error) {
        console.error('Phonics error:', error);
      }
    };

    // Initial: play first letter using phonics
    playFirstLetterPhonics();

    // Start idle reminder timer (3 seconds) - repeat phonics if no input
    idleTimer = window.setTimeout(() => {
      if (currentInput === "") {
        // Kid hasn't typed yet, repeat the first letter phonics
        playFirstLetterPhonics();
        
        // Set up another reminder after 3 more seconds
        idleTimer = window.setTimeout(() => {
          if (currentInput === "") {
            playFirstLetterPhonics();
          }
        }, 3000);
      }
    }, 3000);

    // Cleanup on unmount or when dependencies change
    return () => {
      if (idleTimer) {
        clearTimeout(idleTimer);
        idleTimer = null;
      }
    };
  }, [currentWord?.id, showBalloons]);

  /* CATEGORY FILTER */
  useEffect(() => {
    hardStopAudio();

    // kill celebration timers
    if (celebrationTimerRef.current) {
      clearTimeout(celebrationTimerRef.current);
      celebrationTimerRef.current = null;
    }

    setShowBalloons(false);
    setBalloons([]);
    setStars([]);
    setConfetti([]);

    const mode = getImageDisplayMode();

    const filtered =
      selectedCategory === "all"
        ? allWords
        : allWords.filter(w => w.category_id === selectedCategory);

    let ordered = [...filtered];
    if (mode === "S") ordered.reverse();

    setWords(ordered);
    setCurrentIndex(0);
  }, [selectedCategory, allWords]);

  /* ANIMATION RACE LOCK ON CATEGORY CHANGE */
  useEffect(() => {
    setCategoryChanging(true);

    if (categoryChangeTimerRef.current) {
      clearTimeout(categoryChangeTimerRef.current);
    }

    categoryChangeTimerRef.current = window.setTimeout(() => {
      setCategoryChanging(false);
      categoryChangeTimerRef.current = null;
    }, 200);

    return () => {
      if (categoryChangeTimerRef.current) {
        clearTimeout(categoryChangeTimerRef.current);
        categoryChangeTimerRef.current = null;
      }
    };
  }, [selectedCategory]);

  useEffect(() => {
    if (categoryChanging) hardStopAudio();
  }, [categoryChanging]);

  const handleCategoryChange = (value: string) => {
    setPendingCategory(value);

    if (categoryDebounceRef.current) {
      clearTimeout(categoryDebounceRef.current);
    }

    categoryDebounceRef.current = window.setTimeout(() => {
      setSelectedCategory(value);
      categoryDebounceRef.current = null;
    }, 250);
  };

  /* PLAY CLAP SOUND */
  const playClap = () => {
    try {
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const now = audioContext.currentTime;
      
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      
      osc.frequency.setValueAtTime(150, now);
      osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
      gain.gain.setValueAtTime(0.3, now);
      gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      
      osc.start(now);
      osc.stop(now + 0.15);
    } catch {
      // fail silently
    }
  };

  /* INPUT HANDLERS */
  const handleInputChange = (value: string) => {
    if (!currentWord) return;

    const lower = value.toLowerCase();
    if (!currentWord.word.startsWith(lower)) return;

    setCurrentInput(lower);

    // Reset idle timer on any input
    if (idleTimer) {
      clearTimeout(idleTimer);
      idleTimer = null;
    }

    if (lower.length < currentWord.word.length) {
      const next = currentWord.word[lower.length];
      setSuggestion(next.toUpperCase());
      setHighlightedKey(next.toLowerCase());
      
      // Play next letter audio using phonics (hybrid: phonics for letters)
      const playNextLetter = async () => {
        try {
          // Use phonics for individual letter sounds
          await playPhonics(next);
        } catch (error) {
          console.error('Phonics playback error:', error);
        }
      };

      setTimeout(() => {
        hardStopAudio();
        playNextLetter();
        
        // Restart idle timer
        idleTimer = window.setTimeout(() => {
          // Repeat the last letter sound as a hint
          playPhonics(next).catch(console.error);
        }, 2500);
      }, 400);
    } else {
      // Word completed
      setSuggestion("");
      setHighlightedKey("");
      setWordCompleted(true);

      const word = currentWord.word;

      // Stop active phonics playback only (keeps TTS audio context intact)
      stopAudio();

      console.log("WORD COMPLETE", word);
      // Speak completion using TTS (fire-and-forget)
      speakWordTTS(word);
      
      // Haptic feedback
      hapticTap(50);
      
      // Decide flow based on celebration toggle
      if (getCelebrationEnabled()) {
        runCelebrationThenChangeImage();
      } else {
        changeImage();
      }
    }
  };

  const handleKeyClick = (l: string) => {
    handleInputChange(currentInput + l.toLowerCase());
  };

  const handleBackspace = () =>
    handleInputChange(currentInput.slice(0, -1));

  const handleClear = () => handleInputChange("");

  const goPrevious = () => {
    // Reset state BEFORE moving
    setWordCompleted(false);
    setCurrentInput("");
    setCurrentIndex(i => (i - 1 + words.length) % words.length);
  };

  const goNext = () => {
    // Reset state BEFORE moving
    setWordCompleted(false);
    setCurrentInput("");
    setCurrentIndex(i => (i + 1) % words.length);
  };

  const handleBalloonPop = (balloonId: number, e: React.MouseEvent) => {
    const rect = (e.target as HTMLElement).getBoundingClientRect();
    const x = e.clientX - rect.left + rect.width / 2;
    const y = e.clientY - rect.top + rect.height / 2;
    
    console.log("BALLOON POPPED:", balloonId);
    
    // Create celebration stars
    const newStars = Array.from({ length: 8 }, (_, i) => ({
      id: Date.now() + i,
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2
    }));
    setStars(prev => [...prev, ...newStars]);
    
    // Remove stars after animation
    setTimeout(() => {
      setStars(prev => prev.filter(s => !newStars.find(ns => ns.id === s.id)));
    }, 1000);
    
    // Mark balloon as popped and check if all are popped
    setBalloons(prev => {
      const updated = prev.map(b =>
        b.id === balloonId ? { ...b, popped: true } : b
      );

      console.log("Updated balloons:", updated);
      const allPopped = updated.every(b => b.popped);
      console.log("All popped?", allPopped);
      
      if (allPopped) {
        console.log("ALL BALLOONS POPPED - Starting cleanup");
        if (celebrationTimerRef.current) {
          clearTimeout(celebrationTimerRef.current);
          celebrationTimerRef.current = null;
        }

        setTimeout(() => {
          console.log("Starting UI cleanup after 1200ms");
          // Clear celebration UI first
          setShowBalloons(false);
          setStars([]);
          
          // Wait for UI to clear before changing image
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              console.log("Balloons cleared - now calling changeImage");
              changeImage();
            });
          });
        }, 1200);
      }

      return updated;
    });
  };

  /* =========================
     UI
  ========================= */
  return (
    <div className="h-[100dvh] w-full overflow-hidden flex flex-col bg-gradient-to-br from-primary/10 to-secondary/10 relative">
      {/* Cartoon background decorations */}
      <div className="absolute top-8 left-4 w-20 h-20 bg-yellow-300 rounded-full opacity-70 blur-sm"></div>
      <div className="absolute top-32 right-8 w-32 h-32 bg-blue-300 rounded-full opacity-60 blur-lg"></div>
      <div className="absolute bottom-40 left-8 w-24 h-24 bg-pink-300 rounded-full opacity-50 blur-md"></div>
      <div className="absolute bottom-20 right-12 w-28 h-28 bg-green-300 rounded-full opacity-60 blur-lg"></div>
      <div className="absolute top-1/3 right-20 w-16 h-16 bg-purple-300 rounded-full opacity-40 blur-md"></div>

      {/* HEADER */}
      <div className="bg-gradient-to-r from-primary to-secondary p-3 rounded-b-3xl shadow-lg relative z-10">
        <div className="flex justify-between items-center px-3">
          <h1 className="text-2xl font-black text-white drop-shadow-lg">üé® Word Learning</h1>
          <div className="flex items-center gap-3">
            <Select value={pendingCategory} onValueChange={handleCategoryChange}>
              <SelectTrigger className="h-9 w-[140px] bg-white/30 text-white font-bold rounded-full">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">üåü All</SelectItem>
                {categories.map(c => (
                  <SelectItem key={c.id} value={c.id}>
                    {c.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button
              onClick={() => navigate("/settings")}
              size="icon"
              className="bg-white/30 text-white h-9 w-9 rounded-full hover:bg-white/50"
            >
              <Settings className="h-5 w-5" />
            </Button>
          </div>
        </div>
      </div>

      {/* MODE */}
      <div className="flex justify-end gap-2 px-4 py-2">
        <Image className={mode === "image-first" ? "text-primary" : ""} />
        <Switch
          checked={mode === "word-first"}
          onCheckedChange={c => setMode(c ? "word-first" : "image-first")}
        />
        <Type className={mode === "word-first" ? "text-primary" : ""} />
      </div>

      {/* NO WORDS MESSAGE */}
      {(!words.length || !currentWord) && (
        <div className="flex-1 flex items-center justify-center p-8">
          <div className="text-center space-y-4">
            <div className="text-6xl">üìö</div>
            <h2 className="text-2xl font-bold text-gray-700">No Words Available</h2>
            <p className="text-gray-500">Add some words in Settings to start learning!</p>
            <Button
              onClick={() => navigate("/settings")}
              className="bg-primary text-white mt-4"
            >
              <Settings className="mr-2 h-4 w-4" />
              Go to Settings
            </Button>
          </div>
        </div>
      )}

      {/* ========================================
           LAYOUT 1: MOBILE PORTRAIT
      ======================================== */}
      {words.length > 0 && layout === 'mobile-portrait' && (
        <>
          <div className="flex-1 flex flex-col items-center gap-4 px-3 pt-4 pb-[280px]">
            {/* IMAGE */}
            <div className="w-full flex items-center justify-center gap-2 px-3">
              <button
                onClick={goPrevious}
                className="shrink-0 rounded-full bg-white/30 p-2 hover:scale-110 transition-transform"
              >
                <ChevronLeft className="w-7 h-7 text-white drop-shadow" />
              </button>

              <div className="relative w-[80%] max-w-[352px]">
                {!categoryChanging && currentWord && (
                  <div key={`${currentWord.id}-${currentIndex}`} className="w-full aspect-square rounded-3xl border-4 border-white shadow-2xl drop-shadow-xl overflow-hidden flex items-center justify-center bg-white image-transition">
                    {imageSrc && (
                      <img
                        key={`img-${imageKey}`}
                        src={imageSrc}
                        alt={currentWord.word}
                        className="object-cover w-full h-full image-fade-transition"
                      />
                    )}
                  </div>
                )}

                {currentWord && mode === "word-first" && !wordCompleted && (
                  <div className="w-full aspect-square rounded-3xl border-4 border-dashed border-blue-400 flex items-center justify-center bg-white/40 shadow-xl">
                    <span className="text-8xl animate-bounce">‚ùì</span>
                  </div>
                )}
              </div>

              <button
                onClick={goNext}
                className="shrink-0 rounded-full bg-white/30 p-2 hover:scale-110 transition-transform"
              >
                <ChevronRight className="w-7 h-7 text-white drop-shadow"/>
              </button>
            </div>

            {/* WORD INPUT */}
            <div className="w-full flex items-center justify-center">
              <WordInput
                value={currentInput}
                suggestion={suggestion}
                wordLength={currentWord?.word.length || 0}
              />
            </div>
          </div>

          {/* KEYBOARD - FIXED BOTTOM */}
          <div className="fixed bottom-0 left-0 right-0">
            <VirtualKeyboard
              onKeyClick={handleKeyClick}
              onBackspace={handleBackspace}
              onClear={handleClear}
              highlightedKey={highlightedKey}
              layoutMode="mobile-portrait"
            />
          </div>
        </>
      )}

      {/* ========================================
           LAYOUT 2: MOBILE LANDSCAPE
      ======================================== */}
      {words.length > 0 && layout === 'mobile-landscape' && (
        <div className="flex-1 flex flex-row h-full">
          {/* LEFT: IMAGE */}
          <div className="relative w-1/2 flex items-center justify-center p-2">
            <button onClick={goPrevious} className="absolute left-2 z-10">
              <ChevronLeft />
            </button>

            {!categoryChanging && currentWord && (
              <div className="rounded-xl overflow-hidden flex items-center justify-center bg-white">
                {imageSrc && (
                  <img
                    key={`img-${imageKey}`}
                    src={imageSrc}
                    alt={currentWord.word}
                    className="object-contain rounded-xl max-h-[calc(100dvh-120px)] max-w-full image-transition"
                  />
                )}
              </div>
            )}

            {currentWord && mode === "word-first" && !wordCompleted && (
              <div className="w-full h-[calc(100dvh-120px)] max-w-[400px] rounded-xl border-4 border-dashed border-primary/30 flex items-center justify-center bg-primary/5">
                <span className="text-6xl">‚ùì</span>
              </div>
            )}

            <button onClick={goNext} className="absolute right-2 z-10">
              <ChevronRight />
            </button>
          </div>

          {/* RIGHT: WORD INPUT + KEYBOARD */}
          <div className="w-1/2 flex flex-col h-full">
            {/* WORD INPUT - TOP */}
            <div className="flex-1 flex items-center justify-center px-4">
              <WordInput
                value={currentInput}
                suggestion={suggestion}
                wordLength={currentWord?.word.length || 0}
              />
            </div>

            {/* KEYBOARD - BOTTOM */}
            <div className="shrink-0">
              <VirtualKeyboard
                onKeyClick={handleKeyClick}
                onBackspace={handleBackspace}
                onClear={handleClear}
                highlightedKey={highlightedKey}
                layoutMode="mobile-landscape"
              />
            </div>
          </div>
        </div>
      )}

      {/* ========================================
           LAYOUT 3: IPAD PORTRAIT
      ======================================== */}
      {words.length > 0 && layout === 'ipad-portrait' && (
        <>
          <div className="flex-1 flex flex-col pb-[280px]">
            {/* IMAGE */}
            <div className="relative flex-initial flex items-start justify-center p-3 pt-12">
              <button onClick={goPrevious} className="absolute left-3 top-1/2 -translate-y-1/2 z-10 hover:scale-110 transition-transform">
                <ChevronLeft className="w-8 h-8 text-white drop-shadow-lg" />
              </button>

              {!categoryChanging && currentWord && (
                <div key={`${currentWord.id}-${currentIndex}`} className="w-[68%] aspect-square max-w-[400px] rounded-3xl border-4 border-white shadow-2xl drop-shadow-xl overflow-hidden flex items-center justify-center bg-white image-transition">
                  {imageSrc && (
                    <img
                      key={`img-${imageKey}`}
                      src={imageSrc}
                      alt={currentWord.word}
                      className="object-cover w-full h-full rounded-[1.25rem] image-fade-transition"
                    />
                  )}
                </div>
              )}

              {currentWord && mode === "word-first" && !wordCompleted && (
                <div className="w-[68%] aspect-square max-w-[400px] rounded-3xl border-4 border-dashed border-blue-400 flex items-center justify-center bg-white/40 shadow-xl">
                  <span className="text-9xl animate-bounce">‚ùì</span>
                </div>
              )}

              <button onClick={goNext} className="absolute right-3 top-1/2 -translate-y-1/2 z-10 hover:scale-110 transition-transform">
                <ChevronRight className="w-8 h-8 text-white drop-shadow-lg"/>
              </button>
            </div>

            {/* WORD INPUT */}
            <div className="flex items-center justify-center min-h-[60px] px-4 pt-3">
              <WordInput
                value={currentInput}
                suggestion={suggestion}
                wordLength={currentWord?.word.length || 0}
              />
            </div>
          </div>

          {/* KEYBOARD - FIXED BOTTOM */}
          <div className="fixed bottom-0 left-0 right-0">
            <VirtualKeyboard
              onKeyClick={handleKeyClick}
              onBackspace={handleBackspace}
              onClear={handleClear}
              highlightedKey={highlightedKey}
              layoutMode="ipad-portrait"
            />
          </div>
        </>
      )}

      {/* ========================================
           LAYOUT 4: IPAD LANDSCAPE
      ======================================== */}
      {words.length > 0 && layout === 'ipad-landscape' && (
        <>
          <div className="flex-1 flex flex-row pb-[280px]">
            {/* LEFT: IMAGE */}
            <div className="relative w-1/2 flex items-center justify-center p-2 -translate-y-3">
              <button onClick={goPrevious} className="absolute left-2 z-10">
                <ChevronLeft />
              </button>

              {!categoryChanging && currentWord && (
                <div key={`${currentWord.id}-${currentIndex}`} className="rounded-3xl border-4 border-white shadow-2xl drop-shadow-xl overflow-hidden flex items-center justify-center bg-white w-[480px] h-[300px] image-transition">
                  {imageSrc && (
                    <img
                      key={`img-${imageKey}`}
                      src={imageSrc}
                      alt={currentWord.word}
                      className="object-contain w-full h-full image-fade-transition"
                    />
                  )}
                </div>
              )}

              {currentWord && mode === "word-first" && !wordCompleted && (
                <div className="w-[480px] h-[300px] rounded-3xl border-4 border-dashed border-primary/30 flex items-center justify-center bg-primary/5">
                  <span className="text-6xl">‚ùì</span>
                </div>
              )}

              <button onClick={goNext} className="absolute right-2 z-10">
                <ChevronRight />
              </button>
            </div>

            {/* RIGHT: WORD INPUT */}
            <div className="w-1/2 flex items-center justify-center px-4">
              <WordInput
                value={currentInput}
                suggestion={suggestion}
                wordLength={currentWord?.word.length || 0}
              />
            </div>
          </div>

          {/* KEYBOARD - FIXED FULL BOTTOM */}
          <div className="fixed bottom-0 left-0 right-0">
            <VirtualKeyboard
              onKeyClick={handleKeyClick}
              onBackspace={handleBackspace}
              onClear={handleClear}
              highlightedKey={highlightedKey}
              layoutMode="ipad-landscape"
            />
          </div>
        </>
      )}

      {/* ========================================
           CELEBRATION BALLOONS
      ======================================== */}
      {showBalloons && (
        <div className="fixed inset-0 pointer-events-none z-50">
          {balloons.filter(b => !b.popped).map((balloon, index) => {
            const colors = [
              { body: "#ff6b6b", knot: "#dc2626", gradient: "url(#gradientRed)" },
              { body: "#60a5fa", knot: "#3b82f6", gradient: "url(#gradientBlue)" },
              { body: "#fbbf24", knot: "#f59e0b", gradient: "url(#gradientYellow)" },
              { body: "#34d399", knot: "#10b981", gradient: "url(#gradientGreen)" }
            ];
            const color = colors[index % 4];
            
            return (
              <div
                key={balloon.id}
                onClick={(e) => handleBalloonPop(balloon.id, e)}
                className="pointer-events-auto cursor-pointer"
                style={{
                  position: 'fixed',
                  left: `${balloon.x}%`,
                  bottom: '-100px',
                  animation: `floatUpSlow 15s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards`,
                  animationDelay: `${index * 0.4}s`,
                  width: '120px',
                  height: '200px',
                }}
              >
                <div className="relative w-full h-full flex flex-col items-center group hover:scale-110 transition-transform">
                  {/* Balloon SVG */}
                  <svg width="120" height="140" viewBox="0 0 120 140" className="drop-shadow-2xl flex-shrink-0">
                    {/* Balloon body */}
                    <ellipse 
                      cx="60" 
                      cy="60" 
                      rx="50" 
                      ry="58" 
                      fill={color.gradient}
                      stroke="#fff"
                      strokeWidth="2"
                      className="filter drop-shadow-lg"
                    />
                    {/* Shine effect */}
                    <ellipse 
                      cx="42" 
                      cy="35" 
                      rx="20" 
                      ry="28" 
                      fill="rgba(255, 255, 255, 0.35)"
                    />
                    {/* Balloon knot */}
                    <path 
                      d="M 60 118 Q 55 125 60 130 Q 65 125 60 118" 
                      fill={color.knot}
                    />
                    <defs>
                      <radialGradient id="gradientRed" cx="40%" cy="40%">
                        <stop offset="0%" stopColor="#ff8080" />
                        <stop offset="100%" stopColor="#dc2626" />
                      </radialGradient>
                      <radialGradient id="gradientBlue" cx="40%" cy="40%">
                        <stop offset="0%" stopColor="#93c5fd" />
                        <stop offset="100%" stopColor="#3b82f6" />
                      </radialGradient>
                      <radialGradient id="gradientYellow" cx="40%" cy="40%">
                        <stop offset="0%" stopColor="#fcd34d" />
                        <stop offset="100%" stopColor="#f59e0b" />
                      </radialGradient>
                      <radialGradient id="gradientGreen" cx="40%" cy="40%">
                        <stop offset="0%" stopColor="#6ee7b7" />
                        <stop offset="100%" stopColor="#10b981" />
                      </radialGradient>
                    </defs>
                  </svg>
                  
                  {/* String */}
                  <div className="w-1 h-16 bg-gradient-to-b from-gray-400 to-gray-600 flex-shrink-0"></div>
                </div>
              </div>
            );
          })}
        </div>
      )}

      {/* CELEBRATION STARS */}
      {stars.map((star) => (
        <div
          key={star.id}
          className="fixed pointer-events-none z-50 animate-starBurst"
          style={{
            left: `${star.x}px`,
            top: `${star.y}px`,
          }}
        >
          <span className="text-4xl">‚≠ê</span>
        </div>
      ))}

      {/* CONFETTI BURST */}
      {confetti.map((piece) => (
        <div
          key={piece.id}
          className="fixed pointer-events-none z-50"
          style={{
            left: `${piece.x}px`,
            top: `${piece.y}px`,
            animation: `confettiFall 2s ease-in forwards`,
            opacity: 1,
            transform: `translate(${piece.vx * 20}px, ${piece.vy * 20}px) rotate(${Math.random() * 360}deg)`,
          }}
        >
          <span className="text-2xl">{['üéâ', '‚ú®', 'üåü', 'üí´', 'üéä'][Math.floor(Math.random() * 5)]}</span>
        </div>
      ))}
    </div>
  );
};

export default Learning;
